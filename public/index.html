<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>React Redux UnderTheHood</title>
  <link rel="stylesheet" href="styles.css">
  <script crossorigin src="https://unpkg.com/react@17/umd/react.development.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@17/umd/react-dom.development.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</head>

<body>
  <div id="root"></div>

  <script type="text/babel">

    // Imitate API
    const api = {
      get(url) {
        switch (url) {
          case '/lots':
            return new Promise((resolve, _) => {
              const mockLots = [
                {
                  id: 1,
                  name: "Apple",
                  description: "Apple description",
                  price: 16
                }, {
                  id: 2,
                  name: "Orange",
                  description: "Orange description",
                  price: 41
                }]

              // resolve promise with mocked lots after timeout to imitate fetching
              setTimeout(() => {
                resolve(mockLots)
              }, 1000)

            })
          default:
            throw new Error('Unknown address')
        }
      }
    }

    // Imitate web sockets
    const stream = {
      subscribe(channel, listener) {
        const match = /price-(\d+)/.exec(channel)
        if (match) {
          setInterval(() => {
            listener({
              id: parseInt(match[1]),
              price: Math.round(Math.random() * 10 + 30)
            })
          }, 400)
        }
      }
    }

    // ACTIONS
    const SET_TIME = 'SET_TIME'
    const SET_LOTS = 'SET_LOTS'
    const CHANGE_LOT_PRICE = 'CHANGE_LOT_PRICE'

    // Action creators
    function setTime(time) {
      return {
        type: SET_TIME,
        payload: time,
      }
    }

    function setLots(lots) {
      return {
        type: SET_LOTS,
        payload: lots,
      }
    }

    function changeLotPrice(data) {
      return {
        type: CHANGE_LOT_PRICE,
        payload: data,
      }
    }

    // combine reducers
    function combineReducers(reducers) {
      return (state, action) => {
        const result = {}
        Object.entries(reducers).forEach(([key, reducer]) => {
          result[key] = reducer(state[key], action)
        })
        return result
      }
    }

    function clockReducer(state = clockInitialState, action) {
      switch (action.type) {
        case SET_TIME:
          return {
            ...state,
            time: action.payload
          }
        default:
          return state
      }
    }

    function auctionReducer(state = auctionInitialState, action) {
      switch (action.type) {
        case SET_LOTS:
          return {
            ...state,
            lots: action.payload
          }
        case CHANGE_LOT_PRICE:
          return {
            ...state,
            lots: state.lots.map(lot => {
              if (lot.id !== action.payload.id) return lot
              return { ...lot, price: action.payload.price }
            })
          }
        default:
          return state
      }
    }

    // State
    const clockInitialState = {
      time: new Date(),
    }
    const auctionInitialState = {
      lots: null
    }

    function createStore(reducer) {
      let state = reducer(state = {}, { type: '' })
      let listeners = []

      return {
        getState: () => state,
        dispatch(action) {
          state = reducer(state, action)
          listeners.forEach(listener => listener())
        },
        subscribe(listener) {
          listeners.push(listener)
          return () => {
            const index = this.listeners.indexOf(listener)
            listeners.splice(index, 1)
          }
        },
      }
    }

    const store = createStore(combineReducers({
      clock: clockReducer,
      auction: auctionReducer
    }))

    // subscribe to re-render on every state update
    store.subscribe(() => {
      renderApp(store.getState())
    })

    // App node
    function App({ state }) {
      return (
        <main className="app">
          <Header />
          <Clock time={state.clock.time} />
          <Lots lots={state.auction.lots} />
        </main>
      )
    }

    // Header node
    function Header() {
      return (
        <header className="header">
          <Logo />
        </header>
      )
    }

    // Logo node
    function Logo() {
      return <img className="logo" src="./chilli.png" alt="Chilli illustration" />
    }

    // Clock node
    function Clock({ time }) {
      const isDay = time.getHours() >= 7 && time.getHours() <= 21

      return (
        <div className="clock">
          <span className="value">{time.toLocaleTimeString()}</span>
          <span className={isDay ? 'icon day' : 'icon night'} />
        </div>
      )
    }

    // Loading node
    function Loading() {
      return <div className="loading">Loading</div>
    }

    // Lots node
    function Lots({ lots }) {
      if (lots === null) {
        return <Loading />
      }

      return (
        <div className="lots">
          {lots.map(lot => <Lot key={lot.id} lot={lot} />)}
        </div>
      )
    }

    // Lot node
    function Lot({ lot, key }) {
      return (
        <article className="lot">
          <div className="price">{lot.price}</div>
          <h1>{lot.name}</h1>
          <p>{lot.description}</p>
        </article>
      )
    }

    // Render app helper
    function renderApp(state) {
      ReactDOM.render(
        <App state={state} />,
        document.getElementById('root')
      )
    }

    // First render
    renderApp(store.getState())

    // Make api call after first render
    api.get('/lots')
      .then(lots => {
        store.dispatch(setLots(lots))

        // subscribe to a pseudo web socket to update prices for each lots element
        lots.forEach(lot => {
          stream.subscribe(`price-${lot.id}`, (data) => {
            store.dispatch(changeLotPrice(data))
          })
        })
      })
      .catch(console.log)

    // Rerender the app on each tick (time update)
    setInterval(() => {
      store.dispatch(setTime(new Date()))
    }, 1000)
  </script>
</body>

</html>
